# 01 - 背景知識

このセクションでは、ft_printf を実装するために必要な背景知識を、「なぜそうなっているのか」という視点から深く解説します。単に仕様を覚えるのではなく、設計の意図と歴史的経緯を理解することが目標です。

---

## 1. printf の歴史と設計思想

### 1.1 printf の起源

printf は1970年代初頭、Unix オペレーティングシステムと共に誕生しました。その歴史を知ることは、なぜ printf がこのような設計になっているかを理解する助けになります。

**1972年 - C 言語の誕生（Dennis Ritchie）**

C 言語が Bell Labs で開発された当初から、書式付き出力関数の必要性は認識されていました。当時のコンピュータはメモリが極めて限られていたため（PDP-11 のメモリは最大 256KB）、1つの関数で様々な型の出力を処理できる仕組みが求められました。

もし printf がなければ、以下のように型ごとに別の関数を呼ぶ必要があったでしょう。

```c
/* printf がない世界 */
print_string("The answer is ");
print_int(42);
print_string(" and address is ");
print_pointer(&x);
print_newline();

/* printf がある世界 */
printf("The answer is %d and address is %p\n", 42, &x);
```

printf は **1つの関数呼び出しで複数の型の値をフォーマットして出力できる** という、当時としては画期的な設計でした。

**1978年 - K&R C（"The C Programming Language" 初版）**

Brian Kernighan と Dennis Ritchie による教科書の出版で、printf の仕様が広く知られるようになりました。この時点では、まだ C 言語に正式な標準規格はなく、各コンパイラ間で微妙な差異がありました。

**1989年 - ANSI C（C89/C90）**

printf の仕様が初めて正式に標準化されました。`<stdarg.h>` ヘッダが導入され、可変長引数の処理方法が統一されました。それ以前は `<varargs.h>` という非標準のヘッダが使われていました。

**1999年 - C99**

`%zu`（size_t 用）、`%jd`（intmax_t 用）などの新しい変換指定子が追加されました。`va_copy` マクロもこの標準で追加されました。

### 1.2 なぜ format string という設計なのか

printf が format string（書式文字列）を使う設計には、深い理由があります。

**理由1: 型安全性の欠如を補うため**

C 言語は静的型付け言語ですが、可変長引数には型情報がありません。format string は「次の引数がどの型であるか」をプログラマが明示的に指定する仕組みです。

```c
printf("%d", 42);      /* 「次の引数は int だよ」 */
printf("%s", "hello"); /* 「次の引数は char * だよ」 */
```

これはC言語の設計上の限界（可変長引数に型情報が含まれない）に対する実用的な解決策です。

> **重要**: format string と実際の引数の型が一致しない場合、undefined behavior（未定義動作）になります。コンパイラは `-Wformat` フラグでこの不一致を検出できますが、実行時にはチェックされません。

**理由2: 出力形式の柔軟な制御**

format string は単なる型指定ではなく、出力のフォーマット（幅、精度、パディング等）も制御できます。これにより、1つの関数で多様な出力形式に対応できます。

```c
printf("%10d", 42);     /* 幅10で右寄せ: "        42" */
printf("%-10d", 42);    /* 幅10で左寄せ: "42        " */
printf("%010d", 42);    /* 幅10でゼロ埋め: "0000000042" */
printf("%.5f", 3.14);   /* 小数5桁: "3.14000"        */
```

**理由3: 国際化（i18n）への対応**

format string を変更するだけで、出力のレイアウトを変えられます。これは後のソフトウェア国際化で重要になりました。

```c
/* 英語 */
printf("Hello %s, you have %d messages.\n", name, count);
/* 日本語（語順が違う） */
printf("%sさん、%d件のメッセージがあります。\n", name, count);
```

### 1.3 ft_printf と本物の printf の違い

ft_printf は printf の学習用サブセットです。本物の printf との主な違いを理解しておきましょう。

| 機能 | 本物の printf | ft_printf (mandatory) |
|------|-------------|----------------------|
| バッファリング | あり（stdio バッファ） | なし（直接 write） |
| 変換指定子 | 全種（%f, %e, %g, %n 等） | 9種のみ |
| フラグ・幅・精度 | 完全対応 | なし（bonus で一部対応） |
| ロケール対応 | あり | なし |
| ワイド文字対応 | あり（%ls, %lc） | なし |
| スレッドセーフ | 実装による | 非考慮 |
| 出力先 | stdout（fprintf は任意の FILE *） | stdout 固定 |

---

## 2. Variadic Functions（可変長引数関数）

### 2.1 可変長引数とは何か

C 言語では、引数の数が固定されていない関数を定義できます。これを **variadic function（可変長引数関数）** と呼びます。

```c
int printf(const char *format, ...);
/*                              ^^^ これが「可変長引数」を表す */
```

`...`（ellipsis、省略記号）は「ここに0個以上の任意の型の引数が来る」ことを意味します。

### 2.2 なぜ可変長引数が必要なのか

printf のような関数は、呼び出しのたびに異なる数・異なる型の引数を受け取る必要があります。

```c
printf("Hello");                    /* 引数0個 */
printf("%d", 42);                   /* 引数1個 (int) */
printf("%s is %d", "age", 25);     /* 引数2個 (char*, int) */
printf("%d %d %d", 1, 2, 3);       /* 引数3個 (int, int, int) */
```

引数の数ごとに別の関数を用意するのは現実的ではないため、可変長引数という仕組みが必要です。

### 2.3 stdarg.h の4つのマクロ/型

`<stdarg.h>` ヘッダは、可変長引数にアクセスするための型とマクロを提供します。

#### va_list

```c
va_list args;
```

`va_list` は可変長引数リストを走査するための型です。内部的には、スタックやレジスタ上の引数群の位置を追跡するための情報を保持しています。

> **内部実装の詳細**: x86-64 の System V ABI では、`va_list` は以下のような構造体として実装されています（後述のABI解説で詳しく説明します）。

#### va_start

```c
va_start(args, format);  /* format は最後の固定引数 */
```

`va_list` を初期化します。第2引数には、`...` の直前にある最後の固定引数（named parameter）を指定します。

**なぜ最後の固定引数を指定するのか？**

va_start は「この引数の次のメモリ位置から可変長引数が始まる」ということを知るために、最後の固定引数の位置を起点として使います。つまり、最後の固定引数のアドレスとサイズから、次の引数のアドレスを計算するのです。

```
スタック上のメモリレイアウト（概念的）:
+------------------+
| format の値      |  <-- va_start はここを起点にする
+------------------+
| 第1可変引数      |  <-- va_arg で最初に取得される
+------------------+
| 第2可変引数      |  <-- 次の va_arg で取得される
+------------------+
| ...              |
+------------------+
```

#### va_arg

```c
int n = va_arg(args, int);
char *s = va_arg(args, char *);
```

次の引数を取り出します。第2引数に **取り出す値の型** を指定します。呼び出すたびに内部のポインタが次の引数に進みます。

**極めて重要な注意点: Default Argument Promotion（デフォルト引数昇格）**

可変長引数として渡される値には、**default argument promotion** が適用されます。

| 元の型 | 昇格後の型 | 理由 |
|--------|-----------|------|
| `char` | `int` | 整数昇格（integer promotion） |
| `signed char` | `int` | 整数昇格 |
| `unsigned char` | `int` | 整数昇格 |
| `short` | `int` | 整数昇格 |
| `unsigned short` | `int` | 整数昇格 |
| `float` | `double` | 浮動小数点昇格 |
| `int` | `int` | 変化なし |
| `unsigned int` | `unsigned int` | 変化なし |
| `long` | `long` | 変化なし |
| `void *` | `void *` | 変化なし |

これはC言語の仕様（C11 6.5.2.2p6）で定められています。

**なぜ昇格が起きるのか？**

歴史的な理由です。初期のC言語（K&R C）には関数プロトタイプがなく、すべての関数呼び出しで引数が自動的に昇格されていました。可変長引数ではこの挙動が今でも維持されています。

これにより、以下は **undefined behavior** になります。

```c
/* NG: char は int に昇格されているので int で取得すべき */
char c = va_arg(args, char);    /* undefined behavior! */

/* OK: int で取得してから char にキャスト */
char c = (char)va_arg(args, int);  /* 正しい */
```

```c
/* NG: float は double に昇格されている */
float f = va_arg(args, float);  /* undefined behavior! */

/* OK: double で取得 */
double d = va_arg(args, double);  /* 正しい */
```

#### va_end

```c
va_end(args);
```

`va_list` のクリーンアップを行います。`va_start` を呼んだ後は **必ず** `va_end` を呼ぶ必要があります。

**なぜ va_end が必要なのか？**

多くの実装では `va_end` は何もしない（no-op）マクロですが、一部のプラットフォームではスタックの状態を復元する処理が必要です。移植性のために、常に `va_start` と対になる `va_end` を呼ぶことが C 標準で要求されています。

#### va_copy（C99 で追加）

```c
va_list copy;
va_copy(copy, args);
/* copy を使って引数リストを走査 */
va_end(copy);  /* copy も va_end が必要 */
```

`va_list` のコピーを作成します。ft_printf の mandatory part では通常使いませんが、bonus で可変長引数を2回走査する必要がある場合に使えます。

### 2.4 可変長引数の使用例

```c
#include <stdarg.h>
#include <unistd.h>

int	sum(int count, ...)
{
	va_list	args;
	int		total;
	int		i;

	total = 0;
	va_start(args, count);
	i = 0;
	while (i < count)
	{
		total += va_arg(args, int);
		i++;
	}
	va_end(args);
	return (total);
}
/* sum(3, 10, 20, 30) => 60 */
```

### 2.5 ABI レベルの解説: 可変長引数はどう動くのか

ここからは少し高度な内容ですが、可変長引数が **なぜ** 動くのか、CPU とメモリのレベルで理解しましょう。この知識はデバッグ時に非常に役立ちます。

#### x86-64 System V ABI（Linux, macOS）での関数呼び出し規約

x86-64 アーキテクチャでは、関数の引数は以下のルールで渡されます。

**整数/ポインタ引数:**

| 引数の順番 | 渡される場所 |
|-----------|-------------|
| 第1引数 | RDI レジスタ |
| 第2引数 | RSI レジスタ |
| 第3引数 | RDX レジスタ |
| 第4引数 | RCX レジスタ |
| 第5引数 | R8 レジスタ |
| 第6引数 | R9 レジスタ |
| 第7引数以降 | スタック |

**つまり:**

```c
ft_printf("Hello %s, %d, %p", "world", 42, ptr);
```

この呼び出しでは:
- `"Hello %s, %d, %p"` (format) -> RDI レジスタ
- `"world"` -> RSI レジスタ
- `42` -> RDX レジスタ
- `ptr` -> RCX レジスタ

最初の6個の引数はレジスタで渡されるため、スタックには積まれません。

#### va_list の内部構造（x86-64）

x86-64 の System V ABI では、`va_list` は以下のような構造体です。

```c
/* GCC の内部実装（概念的） */
typedef struct
{
    unsigned int    gp_offset;    /* 次の整数レジスタ引数のオフセット */
    unsigned int    fp_offset;    /* 次の浮動小数点レジスタ引数のオフセット */
    void            *overflow_arg_area;  /* スタック上の引数へのポインタ */
    void            *reg_save_area;      /* レジスタ保存領域へのポインタ */
}   va_list[1];
```

**va_start が行うこと:**

1. 呼び出し時のレジスタの値をメモリ上の「レジスタ保存領域（reg_save_area）」にコピー
2. `gp_offset` を最初の可変引数のレジスタオフセットに設定
3. `overflow_arg_area` をスタック上の引数領域に設定

**va_arg が行うこと:**

1. `gp_offset` が閾値（48 = 6レジスタ x 8バイト）未満なら:
   - `reg_save_area + gp_offset` の位置から値を読み取る
   - `gp_offset` を8（64ビット）進める
2. 閾値以上なら:
   - `overflow_arg_area` の位置（スタック）から値を読み取る
   - `overflow_arg_area` を進める

```
va_arg の動作（概念図）:

reg_save_area（レジスタ保存領域）:
+--------+--------+--------+--------+--------+--------+
|  RDI   |  RSI   |  RDX   |  RCX   |   R8   |   R9   |
| (fmt)  | arg1   | arg2   | arg3   | arg4   | arg5   |
+--------+--------+--------+--------+--------+--------+
          ^
          gp_offset = 8（format の次）

overflow_arg_area（スタック上の追加引数）:
+--------+--------+--------+
| arg6   | arg7   | arg8   |  ← 7個目以降の引数
+--------+--------+--------+
```

#### なぜ va_arg の型指定が重要なのか

va_arg は「指定された型のサイズ分だけポインタを進める」動作をします。型が間違っていると、読み取るバイト数とポインタの進み方が狂い、以降のすべての引数が正しく取得できなくなります。

```
正しい場合: va_arg(args, int) で 4バイト読んで 8バイト進む
            （アライメントにより8バイト単位）

間違った場合: va_arg(args, long long) で 8バイト読んで 8バイト進む
             → int の値をlong longとして読むため、上位4バイトにゴミが入る
```

### 2.6 やってみよう: 可変長引数の実験

**演習1: 引数の数が間違っている場合の動作を観察する**

```c
#include <stdio.h>

int	main(void)
{
	/* 引数が足りない場合（undefined behavior） */
	printf("%d %d %d\n", 1, 2);
	/* 何が出力されるか? => ゴミの値 */

	/* 引数が多い場合 */
	printf("%d\n", 1, 2, 3);
	/* 余分な引数は無視される */

	return (0);
}
```

コンパイルして実行し、何が起きるか観察してみましょう（`-Wformat` フラグが警告を出すことも確認してください）。

**演習2: 型の不一致を体験する**

```c
#include <stdio.h>

int	main(void)
{
	int	n;

	n = 42;
	printf("%s\n", n);  /* int を %s で読もうとする */
	/* 何が起きるか? => segfault の可能性が高い */
	return (0);
}
```

> **警告**: この演習は undefined behavior を意図的に起こすものです。安全な環境で実行し、挙動を観察してください。

---

## 3. printf の内部動作

### 3.1 処理の全体フロー

printf の処理は、大きく以下のステップに分けられます。

```
printf("Hello %s, you are %d years old\n", name, age)
  |
  v
[Step 1] format string を先頭から1文字ずつ走査
  |
  v
[Step 2] 通常の文字（%以外）はバッファに蓄積
  |       'H' -> バッファ
  |       'e' -> バッファ
  |       'l' -> バッファ
  |       'l' -> バッファ
  |       'o' -> バッファ
  |       ' ' -> バッファ
  v
[Step 3] '%' を検出したら、次の文字を読む
  |       '%' -> 変換指定子モードに入る
  |       's' -> 変換指定子 = 's'
  v
[Step 4] 変換指定子に応じて va_arg で引数を取得
  |       va_arg(args, char *) -> name
  v
[Step 5] 取得した値を文字列に変換してバッファに追加
  |       name の文字列をバッファに追加
  v
[Step 6] Step 2 に戻り、走査を続ける
  |
  v
[Step 7] format string の終端に達したらバッファを flush
  |       バッファの内容を write() で出力
  v
[Step 8] 出力した合計文字数を返す
```

### 3.2 本物の printf のバッファリング

本物の printf は、内部に **バッファ（buffer）** を持っています。これは性能上の重要な最適化です。

**バッファリングとは何か？**

文字を1つずつ `write()` system call で出力すると、system call のオーバーヘッドが毎回発生します。system call はユーザーモードからカーネルモードへの切り替え（context switch）を伴うため、非常にコストが高い処理です。

```
バッファリングなし（ft_printf のアプローチ）:
write('H') -> カーネルモード -> ユーザーモード
write('e') -> カーネルモード -> ユーザーモード
write('l') -> カーネルモード -> ユーザーモード
write('l') -> カーネルモード -> ユーザーモード
write('o') -> カーネルモード -> ユーザーモード
=> 5回の system call

バッファリングあり（本物の printf のアプローチ）:
バッファに 'H','e','l','l','o' を蓄積
write("Hello") -> カーネルモード -> ユーザーモード
=> 1回の system call
```

**stdio のバッファリングの種類:**

| 種類 | 動作 | 使われる場面 |
|------|------|-------------|
| 行バッファリング（line buffered） | 改行文字が来たらフラッシュ | 端末への出力（stdout） |
| 完全バッファリング（fully buffered） | バッファが満杯になったらフラッシュ | ファイルへの出力 |
| バッファリングなし（unbuffered） | 即座に出力 | stderr |

**なぜ ft_printf ではバッファリングしないのか？**

1. 42 の subject でバッファ管理が要件に含まれていない
2. `malloc` の使用を最小限にしたい（mandatory では不要）
3. バッファリングの実装は複雑で、本質的な学習目標から外れる
4. ft_printf は教育目的であり、パフォーマンスは二の次

ただし、**この設計選択のトレードオフは理解すべきです**。ft_printf で `ft_printf("%d%d%d", 1, 2, 3)` を呼ぶと、`write()` が少なくとも3回呼ばれます。本物の printf なら1回（またはバッファフラッシュ時に1回）です。

### 3.3 なぜ write() を直接使うのか

ft_printf では `write()` system call を直接使って出力します。なぜ `putchar()` や `fputs()` を使わないのでしょうか。

**理由1: stdio のバッファとの干渉を避ける**

`printf` と `ft_printf` を同じプログラムで使う場合を考えてみましょう。

```c
printf("AAA");          /* stdio のバッファに "AAA" が溜まる */
ft_printf("BBB");       /* write() で "BBB" が直接出力される */
printf("CCC\n");        /* stdio のバッファに "AAACCC\n" が溜まり、
                           改行でフラッシュされる */
```

`putchar` を使うと stdio のバッファに入るため、出力順序が制御しにくくなります。`write()` を直接使えば、stdio のバッファを経由せずに確実に出力されます。

**理由2: 42 の subject で許可されている関数**

subject では `write`, `malloc`, `free`, `va_start`, `va_arg`, `va_copy`, `va_end` のみが使用を許可されています。`putchar` や `puts` は許可されていません。

**理由3: system call を学ぶ教育的意義**

`write()` は Unix/Linux における最も基本的な出力手段です。これを直接使うことで、OS レベルでの I/O の仕組みを学べます。

### 3.4 write() system call の詳細

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```

#### パラメータの詳細

**fd（file descriptor）:**

ファイルディスクリプタは、カーネルが管理するオープンファイルテーブルへの索引番号です。

| fd | 意味 | 説明 |
|----|------|------|
| 0 | stdin（標準入力） | キーボードからの入力 |
| 1 | stdout（標準出力） | 端末への通常出力 |
| 2 | stderr（標準エラー出力） | 端末へのエラー出力 |
| 3+ | ユーザーがオープンしたファイル | open() で取得 |

ft_printf では常に `fd = 1`（stdout）を使用します。

**buf（バッファへのポインタ）:**

書き込むデータの先頭アドレスです。`const void *` 型なので、任意のポインタを渡せます。

```c
char c = 'A';
write(1, &c, 1);        /* char のアドレスを渡す */

char *str = "hello";
write(1, str, 5);       /* 文字列の先頭アドレスを渡す */

write(1, "hello", 5);   /* 文字列リテラルのアドレスを渡す */
```

**count（バイト数）:**

書き込むバイト数を指定します。

#### 戻り値の重要性

```c
ssize_t ret = write(1, "hello", 5);
/* ret == 5: 成功（5バイト書き込んだ） */
/* ret == -1: エラー（errno にエラーコードがセットされる） */
```

**write が失敗するケース:**

| errno | 意味 | 発生状況 |
|-------|------|---------|
| EBADF | 不正なファイルディスクリプタ | fd が閉じられている |
| EFAULT | 不正なバッファアドレス | buf が無効なメモリ |
| ENOSPC | ディスク容量不足 | ファイルへの書き込み時 |
| EPIPE | パイプが壊れている | 読み手のプロセスが終了 |
| EIO | I/O エラー | ハードウェアの問題 |

ft_printf では、`write` の戻り値が `-1` の場合にエラーを伝播させます。これはプログラムの堅牢性（robustness）にとって重要です。

```c
/* 良い例: write のエラーをチェックする */
if (write(1, &c, 1) == -1)
    return (-1);

/* 悪い例: write のエラーを無視する */
write(1, &c, 1);  /* 失敗しても気づかない */
```

---

## 4. Format String の解析

### 4.1 format string の文法

printf の format string は、以下の2種類の要素から構成されます。

1. **通常の文字（ordinary characters）**: `%` 以外のすべての文字。そのまま出力される。
2. **変換指定（conversion specification）**: `%` で始まり、変換指定子（specifier）で終わる。

#### 変換指定の完全な文法（C標準）

```
%[flags][width][.precision][length]specifier
```

| 要素 | 必須？ | ft_printf mandatory | ft_printf bonus |
|------|-------|--------------------|-----------------|
| `%` | 必須 | 対応 | 対応 |
| flags | 任意 | - | `-`, `0`, `#`, `+`, ` ` |
| width | 任意 | - | 対応 |
| `.precision` | 任意 | - | 対応 |
| length | 任意 | - | - |
| specifier | 必須 | `cspdiuxX%` | `cspdiuxX%` |

### 4.2 Mandatory Part の解析アルゴリズム

ft_printf の mandatory part では、`%` の直後の1文字だけを解析すれば十分です。

```
入力: "Hello %s, you are %d!\n"

走査位置 | 文字 | アクション
---------|------|----------
0        | 'H'  | そのまま出力
1        | 'e'  | そのまま出力
2        | 'l'  | そのまま出力
3        | 'l'  | そのまま出力
4        | 'o'  | そのまま出力
5        | ' '  | そのまま出力
6        | '%'  | 変換モードに入る
7        | 's'  | va_arg(args, char *) を取得して文字列出力
8        | ','  | そのまま出力
9        | ' '  | そのまま出力
...      | ...  | ...
18       | '%'  | 変換モードに入る
19       | 'd'  | va_arg(args, int) を取得して数値出力
20       | '!'  | そのまま出力
21       | '\n' | そのまま出力
22       | '\0' | 終了
```

### 4.3 状態遷移図

format string の解析は、2つの状態を持つ有限オートマトン（finite automaton）としてモデル化できます。

```
                          '%' 以外の文字
                     +--------------------+
                     |                    |
                     v                    |
               +----------+              |
          +--->| 通常状態  |--+           |
          |    +----------+  |           |
          |                  | '%' を検出
          |                  v
          |    +----------+
          +----| 変換状態  |
  specifier    +----------+
  を処理して       |
  通常状態に       | 不正な specifier
  戻る             | (例: '\0')
                   v
               [エラー処理]
```

**bonus part ではより複雑な状態遷移が必要:**

```
通常状態 --'%'--> flag解析 --数字/flag--> width解析
   ^               |                       |
   |               | specifier             | '.'
   |               v                       v
   +------------ 変換実行 <---------- precision解析
```

### 4.4 やってみよう: 解析の手動トレース

以下の format string を手動でトレースしてみましょう。

**問題**: `ft_printf("Score: %d/%d (%u%%)\n", 85, 100, 85)` を解析してください。

```
位置 | 文字 | 状態   | アクション           | 出力   | count
-----|------|--------|---------------------|--------|------
0    | 'S'  | 通常   | write('S')          | S      | 1
1    | 'c'  | 通常   | write('c')          | c      | 2
2    | 'o'  | 通常   | write('o')          | o      | 3
3    | 'r'  | 通常   | write('r')          | r      | 4
4    | 'e'  | 通常   | write('e')          | e      | 5
5    | ':'  | 通常   | write(':')          | :      | 6
6    | ' '  | 通常   | write(' ')          |        | 7
7    | '%'  | 変換   | 次の文字を読む      |        | 7
8    | 'd'  | 変換   | va_arg -> 85, 出力  | 85     | 9
9    | '/'  | 通常   | write('/')          | /      | 10
10   | '%'  | 変換   | 次の文字を読む      |        | 10
11   | 'd'  | 変換   | va_arg -> 100, 出力 | 100    | 13
12   | ' '  | 通常   | write(' ')          |        | 14
13   | '('  | 通常   | write('(')          | (      | 15
14   | '%'  | 変換   | 次の文字を読む      |        | 15
15   | 'u'  | 変換   | va_arg -> 85, 出力  | 85     | 17
16   | '%'  | 変換   | 次の文字を読む      |        | 17
17   | '%'  | 変換   | write('%')          | %      | 18
18   | ')'  | 通常   | write(')')          | )      | 19
19   | '\n' | 通常   | write('\n')         | \n     | 20
20   | '\0' |        | 終了                |        | 20

最終出力: "Score: 85/100 (85%)\n"
戻り値: 20
```

---

## 5. 整数の表現

### 5.1 2の補数表現（Two's Complement）

コンピュータが符号付き整数を表現するために使う方式が **2の補数（two's complement）** です。現代のほぼすべてのコンピュータがこの方式を採用しています。

#### なぜ2の補数なのか

整数を表現する方式はいくつかありますが、2の補数が選ばれた理由は:

1. **加算回路が1つで済む**: 符号付きと符号なしの加算を同じ回路で実行できる
2. **ゼロの表現が1つ**: 符号と絶対値方式では +0 と -0 が存在するが、2の補数ではゼロは1つだけ
3. **減算が加算に変換できる**: A - B = A + (-B) = A + (~B + 1)

#### 4ビットでの2の補数表現の全パターン

理解を深めるために、4ビットの場合を見てみましょう。

```
ビットパターン | 符号なし | 2の補数
              | (unsigned)| (signed)
--------------+----------+---------
0000          |    0     |    0
0001          |    1     |    1
0010          |    2     |    2
0011          |    3     |    3
0100          |    4     |    4
0101          |    5     |    5
0110          |    6     |    6
0111          |    7     |    7   <- 正の最大値
1000          |    8     |   -8   <- 負の最小値（!）
1001          |    9     |   -7
1010          |   10     |   -6
1011          |   11     |   -5
1100          |   12     |   -4
1101          |   13     |   -3
1110          |   14     |   -2
1111          |   15     |   -1
```

**重要な観察:**
- 正の最大値は `0111` (= 7 = 2^3 - 1)
- 負の最小値は `1000` (= -8 = -2^3)
- **負の最小値の絶対値（8）は正の最大値（7）より1大きい!**

#### 32ビットの場合（int）

```
INT_MAX =  2147483647 = 0x7FFFFFFF
         = 01111111 11111111 11111111 11111111

INT_MIN = -2147483648 = 0x80000000
         = 10000000 00000000 00000000 00000000

-1      = 4294967295 (unsigned) = 0xFFFFFFFF
         = 11111111 11111111 11111111 11111111

0       = 0x00000000
         = 00000000 00000000 00000000 00000000
```

#### 2の補数の計算方法

正の数から負の数を得るには: **全ビットを反転させて1を加える**

```
5 のビットパターン:  00000101
ビット反転:          11111010
1 を加える:          11111011  <- これが -5

検算: 00000101 + 11111011 = 100000000
      ^--- この桁はオーバーフロー（4ビットからはみ出る）ので捨てる
      結果: 00000000 = 0  OK!
```

### 5.2 INT_MIN の危険性: なぜ -INT_MIN が壊れるのか

**これは ft_printf を実装する上で最も重要な落とし穴の1つです。**

```c
int n = -2147483648;  /* INT_MIN */
int pos = -n;          /* ??? */
```

数学的には `-(-2147483648) = 2147483648` ですが、この値は `int` の最大値 `2147483647` を超えています!

**ビットレベルで何が起きるか:**

```
INT_MIN のビットパターン: 10000000 00000000 00000000 00000000

ビット反転:               01111111 11111111 11111111 11111111
                          = 2147483647 (INT_MAX)

1 を加える:               10000000 00000000 00000000 00000000
                          = -2147483648 (INT_MIN!)

つまり: -INT_MIN == INT_MIN（2の補数の世界では!）
```

> **これは undefined behavior です。** C 標準では符号付き整数のオーバーフローは未定義動作と定められています（C11 6.5p5）。コンパイラは「符号付き整数はオーバーフローしない」と仮定して最適化を行うことがあり、予測不能な結果になります。

**ft_printf での対処法:**

```c
/* INT_MIN を検出して特別処理する */
if (n == -2147483648)
{
    write(1, "-2147483648", 11);
    return (0);
}
/* ここに来る時点で n != INT_MIN なので -n は安全 */
if (n < 0)
{
    write(1, "-", 1);
    n = -n;  /* 安全: n は -2147483647 ~ -1 の範囲 */
}
```

### 5.3 符号なし整数（unsigned int）

符号なし整数は、ビットパターンをそのまま非負の整数として解釈します。

```
unsigned int の範囲: 0 ~ 4294967295 (2^32 - 1)
```

**signed と unsigned の関係:**

同じビットパターンでも、signed と unsigned では解釈が異なります。

```
ビットパターン         | signed int   | unsigned int
-----------------------|-------------|-------------
00000000...00101010    |      42     |       42
11111111...11111111    |      -1     | 4294967295
10000000...00000000    | -2147483648 | 2147483648
```

**暗黙の型変換に注意:**

```c
int           si = -1;
unsigned int  ui = (unsigned int)si;
/* ui = 4294967295 */
/* ビットパターンは同じ、解釈が変わるだけ */
```

### 5.4 やってみよう: 2の補数の計算

**問題1**: 8ビットの2の補数表現で、-42 のビットパターンを求めてください。

```
42  = 00101010
反転 = 11010101
+1  = 11010110  <- -42 のビットパターン

検算: 00101010 + 11010110 = 100000000
      8ビットを超えた部分を捨てると 00000000 = 0  OK!
```

**問題2**: 以下のコードの出力は何でしょうか?

```c
unsigned int u = (unsigned int)(-42);
printf("%u\n", u);
```

答え: `4294967254`（= 2^32 - 42 = 4294967296 - 42）

---

## 6. 16進数（Hexadecimal）と基数変換

### 6.1 なぜ16進数を使うのか

コンピュータの世界で16進数が多用される理由は、**2進数との変換が極めて簡単** だからです。

16 = 2^4 なので、16進数の1桁は2進数の4桁（1ニブル）に正確に対応します。

```
16進 | 2進
-----|------
  0  | 0000
  1  | 0001
  2  | 0010
  ...
  9  | 1001
  a  | 1010
  b  | 1011
  c  | 1100
  d  | 1101
  e  | 1110
  f  | 1111
```

例えば、32ビットの値 `0xDEADBEEF` を2進数に変換するには、各桁を4ビットに展開するだけです。

```
D    E    A    D    B    E    E    F
1101 1110 1010 1101 1011 1110 1110 1111
```

10進数でこれを表現すると `3735928559` になり、ビットパターンとの対応が直感的にわかりません。

### 6.2 基数変換アルゴリズム

10進数を N 進数に変換するアルゴリズムは、**除算と剰余の繰り返し** です。

#### アルゴリズムの数学的証明

任意の非負整数 V を基数 B で表現する場合:

```
V = d_k * B^k + d_(k-1) * B^(k-1) + ... + d_1 * B + d_0
```

ここで各 d_i は 0 <= d_i < B を満たす桁の値です。

**V mod B = d_0** （最下位桁）が得られる理由:

```
V mod B = (d_k * B^k + ... + d_1 * B + d_0) mod B
        = (0 + ... + 0 + d_0) mod B    (B^1 以上の項はBで割り切れる)
        = d_0
```

**V / B** で次の処理対象が得られる理由:

```
V / B = d_k * B^(k-1) + ... + d_1
      （これは残りの上位桁を表す数値）
```

#### 具体例: 255 を16進数に変換

```
Step 1: 255 / 16 = 15, 余り 15 -> f (最下位桁)
Step 2:  15 / 16 =  0, 余り 15 -> f (最上位桁)
Step 3: 商が 0 なので終了

結果を逆順に並べる: ff

検算: f*16 + f = 15*16 + 15 = 240 + 15 = 255  OK!
```

#### 具体例: 42 を16進数に変換

```
Step 1: 42 / 16 = 2, 余り 10 -> a (最下位桁)
Step 2:  2 / 16 = 0, 余り  2 -> 2 (最上位桁)
Step 3: 商が 0 なので終了

結果を逆順に並べる: 2a

検算: 2*16 + a = 2*16 + 10 = 32 + 10 = 42  OK!
```

#### 具体例: 12345 を10進数の桁に分解

```
Step 1: 12345 / 10 = 1234, 余り 5
Step 2:  1234 / 10 =  123, 余り 4
Step 3:   123 / 10 =   12, 余り 3
Step 4:    12 / 10 =    1, 余り 2
Step 5:     1 / 10 =    0, 余り 1
Step 6: 商が 0 なので終了

結果を逆順に並べる: 12345
```

### 6.3 再帰による基数変換の実装

基数変換では「余りを逆順に出力する」必要があります。再帰を使うと、コールスタックが自然にこの「逆順」を実現してくれます。

```c
void	ft_put_hex(unsigned int n)
{
	char	*hex;

	hex = "0123456789abcdef";
	if (n >= 16)
		ft_put_hex(n / 16);  /* 上位桁を先に処理 */
	write(1, &hex[n % 16], 1);  /* 自分の桁を出力 */
}
```

**なぜ再帰で逆順になるのか:**

```
ft_put_hex(255) の呼び出し:

ft_put_hex(255)
  255 >= 16 なので ft_put_hex(255 / 16 = 15) を呼ぶ
    ft_put_hex(15)
      15 < 16 なので再帰しない
      hex[15 % 16] = hex[15] = 'f' を出力  <- 上位桁
    戻る
  hex[255 % 16] = hex[15] = 'f' を出力     <- 下位桁
戻る

出力順: 'f', 'f' => "ff"
```

再帰呼び出しが「先に」行われ、`write` が「後に」実行されるため、上位桁から順に出力されます。これはスタック（LIFO: Last In, First Out）の性質を利用しています。

### 6.4 やってみよう: 基数変換の練習

**問題1**: 1000 を16進数に変換してください。

```
1000 / 16 = 62, 余り 8
  62 / 16 =  3, 余り 14 -> e
   3 / 16 =  0, 余り 3
結果: 3e8

検算: 3*256 + 14*16 + 8 = 768 + 224 + 8 = 1000  OK!
```

**問題2**: 0xCAFE を10進数に変換してください。

```
C*16^3 + A*16^2 + F*16^1 + E*16^0
= 12*4096 + 10*256 + 15*16 + 14*1
= 49152 + 2560 + 240 + 14
= 51966
```

**問題3**: ft_put_hex(1000) の再帰展開を書き出してください。

---

## 7. Pointer の表現

### 7.1 ポインタとメモリアドレス

ポインタ（pointer）は、メモリ上のアドレス（番地）を格納する変数です。

**64ビット環境でのメモリ空間:**

```
0x0000000000000000  +------------------+
                    | 使用不可領域     |  <- NULL (0x0) はここ
0x0000000000001000  +------------------+
                    | テキスト領域     |  <- プログラムのコード
                    +------------------+
                    | データ領域       |  <- グローバル変数
                    +------------------+
                    | ヒープ領域       |  <- malloc で確保
                    |       ↓         |
                    |                  |
                    |       ↑         |
                    | スタック領域     |  <- ローカル変数
0x00007FFFFFFFFFFF  +------------------+
                    | カーネル空間     |  <- OS のメモリ
0xFFFFFFFFFFFFFFFF  +------------------+
```

64ビット環境ではアドレスは8バイト（64ビット）ですが、実際に使われるのは48ビット（`0x0000` から `0x7FFF FFFF FFFF`）です。そのため、ポインタを16進数で表示すると最大12桁程度になります。

### 7.2 %p の出力形式

`%p` は `void *` 型のポインタを16進数で出力します。

```c
int x = 42;
printf("%p\n", (void *)&x);  /* 例: 0x7ffd559ffc54 */
printf("%p\n", NULL);          /* 環境依存 */
```

**%p に `0x` prefix がつく理由:**

これは歴史的な慣例で、「この数値は16進数である」ことを明示するためです。C 言語の数値リテラルでも `0x` prefix を使います（`0xFF`, `0x42` など）。

**NULL ポインタの出力はプラットフォーム依存:**

| プラットフォーム | printf("%p", NULL) の出力 |
|-----------------|--------------------------|
| macOS (Apple clang) | `0x0` |
| Linux (glibc) | `(nil)` |
| Windows (MSVC) | `0000000000000000` |

ft_printf の実装では、このプロジェクトのソースコードでは NULL ポインタに対して `(nil)` を出力する設計を採用しています。42の環境（Linux）に合わせた動作です。

### 7.3 なぜ unsigned long long を使うのか

`%p` の処理では、`void *` を `unsigned long long` にキャストして数値として扱います。

```c
int	ft_print_ptr(unsigned long long ptr)
```

**理由:**

- `void *` のサイズは64ビット環境では8バイト
- `unsigned long long` は最低64ビット保証（C99）
- `unsigned int` は32ビット（4バイト）なので、64ビットアドレスを格納できない

```c
/* NG: 64ビットアドレスが切り詰められる */
unsigned int addr = (unsigned int)ptr;
/* 0x7ffd559ffc54 -> 0x559ffc54 (上位ビットが失われる!) */

/* OK: 64ビットアドレスを完全に保持 */
unsigned long long addr = (unsigned long long)ptr;
/* 0x7ffd559ffc54 -> 0x7ffd559ffc54 (完全) */
```

---

## 8. 文字コード（ASCII）と char 型

### 8.1 ASCII コード

ASCII（American Standard Code for Information Interchange）は、文字を7ビットの数値に対応させるエンコーディングです。

**ft_printf で重要な範囲:**

| 範囲 | 文字 | 説明 |
|------|------|------|
| 0 | NUL | ヌル文字（`'\0'`） |
| 32 | SP | スペース |
| 48-57 | '0'-'9' | 数字 |
| 65-90 | 'A'-'Z' | 大文字アルファベット |
| 97-122 | 'a'-'z' | 小文字アルファベット |

**数字の文字変換で使う性質:**

ASCII では `'0'` から `'9'` が連続した値（48-57）に割り当てられています。これを利用して:

```c
int digit = 7;
char c = digit + '0';  /* c = 7 + 48 = 55 = '7' */

char c = '5';
int digit = c - '0';   /* digit = 53 - 48 = 5 */
```

**16進数の文字変換:**

```c
char *hex = "0123456789abcdef";
char c = hex[10];  /* c = 'a' */
char c = hex[15];  /* c = 'f' */
```

この lookup table 方式は、if-else 文の連鎖よりも簡潔で効率的です。

### 8.2 char 型と int 型の関係

C 言語の `char` 型は1バイト（8ビット）の整数型です。`int` 型は（一般的に）4バイト（32ビット）です。

```
char:   [ 8 bits ]
int:    [ 8 bits ][ 8 bits ][ 8 bits ][ 8 bits ]
```

**%c で int を受け取る理由:**

default argument promotion により、可変長引数として渡される `char` は `int` に昇格されます。そのため `va_arg(args, int)` で受け取り、`unsigned char` にキャストしてから `write` に渡します。

```c
int	ft_print_char(int c)
{
	unsigned char	ch;

	ch = (unsigned char)c;  /* 下位8ビットだけを取り出す */
	if (write(1, &ch, 1) == -1)
		return (-1);
	return (1);
}
```

**なぜ unsigned char にキャストするのか？**

`char` が signed の場合（多くのプラットフォームでデフォルト）、128-255 の値が負の数として扱われる可能性があります。`unsigned char` にキャストすることで、0-255 の全範囲を正しく扱えます。

---

## 9. Static Library（.a ファイル）

### 9.1 Static Library とは何か

Static Library は、複数のオブジェクトファイル（`.o`）をまとめたアーカイブファイルです。

```
source files          object files          static library
+-----------+         +--------+
| printf.c  | --cc--> | printf.o |--+
+-----------+         +--------+   |      +---------------+
| char.c    | --cc--> | char.o   |--+--ar--> libftprintf.a |
+-----------+         +--------+   |      +---------------+
| str.c     | --cc--> | str.o    |--+
+-----------+         +--------+
```

### 9.2 ar コマンドの詳細

```bash
ar rcs libftprintf.a file1.o file2.o file3.o
```

**各フラグの意味:**

| フラグ | 意味 | 詳細 |
|--------|------|------|
| `r` | replace | archive にファイルを追加。既に同名のファイルがあれば置換する |
| `c` | create | archive が存在しない場合に新規作成する。このフラグがないと警告が出る |
| `s` | symbol index | archive にシンボルインデックスを付与する。`ranlib` と同等の効果 |

**シンボルインデックスが必要な理由:**

リンカ（linker）がライブラリから関数を検索する際、シンボルインデックスがあると高速に検索できます。インデックスがない場合、リンカはすべてのオブジェクトファイルを順に調べる必要があります。

### 9.3 Static Library と Dynamic Library の違い

| 項目 | Static Library (.a) | Dynamic Library (.so/.dylib) |
|------|--------------------|-----------------------------|
| リンク時期 | コンパイル時 | 実行時 |
| 実行ファイルサイズ | 大きい（ライブラリコードが組み込まれる） | 小さい |
| 配布 | 実行ファイル単体で動作 | ライブラリファイルも必要 |
| 更新 | ライブラリ変更時は再コンパイル | ライブラリファイル差し替えで可能 |
| メモリ使用量 | プロセスごとにコピー | 複数プロセスで共有可能 |

ft_printf では static library を作成します。これは42の要件であるとともに、学習目的として最もシンプルなライブラリ形式です。

### 9.4 リンクの仕組み

```bash
cc main.c -L. -lftprintf -o program
```

| オプション | 意味 |
|-----------|------|
| `-L.` | ライブラリの検索パスにカレントディレクトリを追加 |
| `-lftprintf` | `libftprintf.a` をリンクする（`lib` prefix と `.a` suffix は自動補完） |
| `-o program` | 出力ファイル名を `program` に指定 |

**リンカの処理:**

1. `main.c` をコンパイルして `main.o` を生成
2. `main.o` 内の未解決シンボル（例: `ft_printf`）を見つける
3. `libftprintf.a` のシンボルインデックスを検索
4. `ft_printf` を含むオブジェクトファイル（`ft_printf.o`）を取り出す
5. `ft_printf.o` が依存する他のオブジェクトファイルも取り出す
6. すべてのオブジェクトファイルを結合して実行ファイルを生成

---

## 10. まとめ: 全体像の整理

### ft_printf の構成要素と対応する背景知識

```
ft_printf
  |
  +-- format string の解析 ---- 文字列走査、状態遷移
  |
  +-- 可変長引数の処理 -------- stdarg.h, ABI, 型昇格
  |
  +-- 文字/文字列の出力 ------- write(), ASCII, char 型
  |
  +-- 整数の出力 -------------- 2の補数, INT_MIN, 基数変換
  |
  +-- 16進数の出力 ------------ 基数変換アルゴリズム, 再帰
  |
  +-- ポインタの出力 ---------- メモリアドレス, 64ビット, 0x prefix
  |
  +-- エラーハンドリング ------ write の戻り値, エラー伝播
  |
  +-- ライブラリ作成 ---------- ar, Makefile, リンク
```

### 理解度セルフチェック

この章を読んだ後、以下の質問に答えられるか確認してください。

- [ ] printf が format string を使う設計になった理由を3つ挙げられるか
- [ ] default argument promotion とは何か、なぜ存在するか説明できるか
- [ ] va_arg で型を間違えると何が起きるか説明できるか
- [ ] 本物の printf と ft_printf のバッファリングの違いを説明できるか
- [ ] 2の補数表現で -INT_MIN がオーバーフローする理由をビットレベルで説明できるか
- [ ] 255 を16進数に変換するアルゴリズムを手で実行できるか
- [ ] static library が作られてリンクされるまでの流れを説明できるか
- [ ] write() system call の3つの引数と戻り値を説明できるか
